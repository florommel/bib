#!/usr/bin/python3
# coding: utf-8

import sys
import itertools
import re
import logging
import datetime
import os.path
import yaml

DATABASE_FILE = os.path.join(os.path.dirname(__file__), "library.myml")

records = list(yaml.load_all(open(DATABASE_FILE)))




def check_schema(schema, obj):
    ret = True
    for field,rules in schema.items():
        required = rules.get('required')
        if type(required) == bool and required \
           or (type(required) == type(lambda:1) and required(obj)):
            assert field in obj,\
                "Required field '%s' is missing: %s" %(field, obj)

        recommended = rules.get('recommended')
        if type(recommended) == bool and recommended and not field in obj:
            logging.warning(
                "Recommended field '%s' is missing: %s",
                field, obj.get('ID'))
            ret = False
        if type(recommended) == type(lambda:1) and recommended(obj) and not field in obj:
            logging.warning(
                "Recommended field '%s' is missing: %s",
                field, obj.get('ID'))
            ret = False
        if field not in obj:
            continue
        if rules.get('type'):
            t = {'int': int,
                 'bool': bool,
                 'boolean': bool,
                 'str': str,
                 'string':str,
                 'date': datetime.date,
                 'float': float,
                 'url': str,
                 'list': list,
                 'dict': dict}[rules.get('type')]
            assert type(obj[field]) is t,\
                "Field '%s' has wrong type: %s != %s" %(field, t, type(obj[field]))

        if rules.get('enum'):
            assert obj[field] in rules['enum'],\
                "Field '%s' has invalid value: %s not in  %s" %(field, obj[field],
                                                                rules['enum'])

    if schema:
        for field in obj.keys() - schema.keys():
            logging.warn("Field not in schema: %s/%s", obj.get('ID'), field)
    return ret

has_ID = lambda record: 'ID' in record
is_thesis = lambda record: re.search('(Studienarbeit|Masterarbeit|Bachelorarbeit|Diplomarbeit)')
is_conference = lambda record: record.get('topic') == 'Conference/Procceedings'

schema = {
    'ID': {'required': True},
    'title': {'required': True, 'type': 'str'},
    # Konferenzb√§nde duerfen auch keinen Author haben
    'author': {'recommended': lambda x: not is_conference(x),
               'type': 'str'},
    'location': {'required':  True,
                 'enum': ['IB', 'IB Schrank', 'CB']},
    'year': {'type': 'int'},
    'summary': {'type': 'str'},
    'description': {'type': 'str'},
    # Ausleihstatus
    'status': {'enum': ['away', 'present']},
    'borrower': {'required': lambda x: x.get('status') == 'away'},
    'type': {'enum': ['DVD', 'CD', 'book', 'proceedings', 'article', 'thesis'],
             'recommended': True},
    'topic': {'required': True,
              'enum': ['Systeme, Systementwurf',
                       'Betriebssysteme',
                       'Manuals',
                       'Studium Beruf',
                       'Sonstiges',
                       'Sicherheit',
                       'Rechnerarchitekturen',
                       'Programmiersprachen',
                       'Parallelrechner',
                       'Organic Computing',
                       'Naturanaloge Verfahren',
                       'Mathematik',
                       'Kommunikationstechnik',
                       'Digitaltechnik',
                       'Grundlagen ET',
                       'HL-Technologie IC',
                       'Grundlagen Informatik',
                       'Entwurfsmethodik',
                       'Education',
                       'Conference/Procceedings',
                       'Habilitation',
                       'Dissertation Allgemein',
                       'Studienarbeit SRA',
                       'Bachelorarbeiten SRA',
                       'Masterarbeiten SRA',
                       'Diplomarbeiten SRA']}
}

warnings = 0
for record in records:
    if len(sys.argv) != 1 and record['ID'] not in sys.argv[1:]:
        continue

    if not check_schema(schema, record):
        yaml.dump(record, sys.stdout, allow_unicode=True, default_flow_style=False)
        print()
        warnings += 1

print("%d records in total" % len(records))
for group, R in itertools.groupby(sorted([x['type'] for x in records])):
    print("  %d type=%s in total" % (len(list(R)), group))

print("%d records with warnings" % warnings)
